---
layout: post
title:  "[高性能Mysql读书笔记]3.创建高性能的索引"
date:   2020-08-29 11:44
tags: Mysql
color: rgb(255,215,0)
cover: '../coverimages/mysql.jpg'
---

## 3 创建高性能的索引

> 索引是一种存储引擎为了快速找到数据的一种数据结构，这是索引的基本作用，在数据量较小的时候，不恰当的索引对数据影响可能还比较小，但当数据量逐渐增大时，性能则会急剧下降

## 3.1索引基础

>在Mysql中，存储引擎索引的方式类似于书本的索引，现在索引中找到页码，然后再去页码中找到内容，Mysql则是现在索引中找到对应值，然后根据匹配的索引找到对应的数据行。例如要执行下面的查询
``` sql
select name from student where stu_id = 5;
```

> 如果在stu_id上面建有索引，则Mysql将使用该索引找到stu_id=5的行（具体机制后面解释），也就是说，Mysql先在索引上按照值进行查找，然后返回所有包含该值的数据行

> 索引可以包含一个列或者多个列的值，索引的顺序也是非常重要的，创建一个包含两个列的索引和创建两个包含一个列的索引是大大不同的

## 3.1.1 索引的类型

> 索引是一种数据结构，但它也有很多种类型，可以为不同的场景中提供更好的性能。在Mysql中，索引的实现是在存储引擎层而不是服务层，所以索引的实现并没有统一的标准；不同存储引擎的索引的工作方式不一样。

**B-Tree索引**

> 存储引擎以不同的方式来使用B-Tree引擎，性能也各有不同，各有优劣。例如，MyISAM使用前缀压缩使得索引更小，而InnoDB则按照数据的原数据进行存储，MyISAM通过数据的物理位置引用被索引的行，而InnoDB则通过主键来引用被索引的行

>B—Tree一般又分为B+Tree和B—Tree

>B树和B+树的主要区别在于，B+树叶子节点存储真实的数据，非叶子节点存储键值，而且一般每个节点的大小都是4kb的整数倍，例用“预加载”技术，便于磁盘对数据的查找，大致如下图，Mysql中默认页大小为16kb，InnoDB用的就是B+Tree，下图为主键索引

![enter description here](https://raw.githubusercontent.com/LazystudentCH/blogImage/master/2020/9/1/[高性能Mysql读书笔记]3.创建高性能的索引/1598972722074.png)

> 尽量使用数字作为主键，便于自增，便于存储，便于排序。根据主键创建的索引又叫做主键索引，如果没有主键，会选择一列唯一索引作为主键，如果还没有，会创建一个隐藏列，叫rowID作为主键。

> 其他一个列或者多个列创建的索引叫做辅助索引，辅助索引叶子节点不存储实际数据，而是存储主键，再根据主键找所需的数据行

> 上文提到的索引对如下类型的查询有效
> * 全职匹配
	> 全值匹配指的是和索引中的所有列进行匹配，例如有abc三个字段一起的索引，对abc三列进行查询。
> * 匹配最左前缀
	> 最左前缀指的是只用索引的第一列
> * 匹配最前列
	> 可以匹配某一列值的开头，比如索引abc，对a,b进行查询，可以用到前两列
> * 匹配范围值
	> 可以使用索引的某一列去查找某个范围，例如索引abc，查询 a > 1，可以用到索引的第一列
> * 精确匹配某一列并范围匹配另一列
> * 只访问索引的查询
	> 这种也被称作“覆盖索引”，后续作详细说明

**B-Tree索引的限制**
>* 如果不是按照索引的最左列开始寻找，则无法使用索引。例如abc三列简历索引，无法单独查找b,c
>* 不能跳过中间的列
>* 如果查询中有某个列的范围查询，则后面的列无法使用索引优化，因为索引依靠排序。
>* like 模糊查询如果以 %开头 无法使用索引，理由同上
>* 出现隐式转换，例如字符串转成数字
>* or 关键字左边和右边没有同时使用索引
>* 在索引字段上使用not，<>，!=。不等于操作符是永远不会用到索引的，因此对它的处理只会产生全表扫描
>* 在索引字段上使用函数，因为索引依赖排序，使用函数产生的结果不一定和原来顺序一样

## 3.2 创建高性能索引

![enter description here](./images/1599144812217.png)

## 3.2.1 独立的列

> 如果查询的列不是独立的，则Mysql就不会去使用索引。“独立的列” 是指索引列不能是表达式的一部分或者函数的参数

>例如 下面这个例子无法使用索引
```sql
select actor_id from actor where actor_id + 1 = 5;
```
> Mysql无法解析方程式，这完全是用户所为，应该养成简化Where语句的习惯，将索引列放在放在比较的单独的一侧

![>](https://raw.githubusercontent.com/LazystudentCH/blogImage/master/2020/9/3/[高性能Mysql读书笔记]3.创建高性能的索引/1599145227077.png)

## 3.2.2 前缀索引和索引选择性
> 有时候需要索引很长的字符列，这会让索引边得很大很慢，但会降低索引的选择性，即过滤掉一部分数据的能力，索引的选择性越高则性能越高，唯一索引的选择性是1，这也是性能最高的索引，同时选择性也是最好的

> 一般情况下，某个列前缀的选择性也是足够高的，足以满足性能。对于text,varchar类型的列，必须使用前缀索引，因为这些列Mysql不允许索引这些列的完全长度

> 诀窍在于选择足够长的前缀以保证较高的选择性，同时又不能太长（节约空间），前缀应该足够长，以使得前缀的索引选择性接近于完整列的索引选择性

> 可以用如下方法计算选择性
![enter description here](https://raw.githubusercontent.com/LazystudentCH/blogImage/master/2020/9/4/[高性能Mysql读书笔记]3.创建高性能的索引/1599148906447.png)

> 然后单独算出每一列的选择性，当某一列接近完整列的选择性的时候，就已经足够了
> 前缀索引是一种能使索引更小、更快的有效办法，但也有另外一个缺陷，Mysql无法使用前缀索引来做order by 和 group by, 也无法使用前缀索引做覆盖扫描

![enter description here](https://raw.githubusercontent.com/LazystudentCH/blogImage/master/2020/9/4/[高性能Mysql读书笔记]3.创建高性能的索引/1599211060757.png)

## 3.2.3 多列索引
> 先来看一个问题，这是一个常见的错误，为所有的列都单独建立索引

![enter description here](https://raw.githubusercontent.com/LazystudentCH/blogImage/master/2020/9/4/[高性能Mysql读书笔记]3.创建高性能的索引/1599211264958.png)

> 在多个列上单独建立索引并不能提高Mysql的查询性能，Mysql 5.0之后的版本引入了"索引合并"的策略，一定程度上可以使用表上多个索引来定位指定的行。

> 5.0之后，查询能够同时使用多个列的索引进行扫描，并将结果合并，这样子会产生三个变种，or and 和 union，Mysql会使用这类技术优化复杂的查询。

> 索引合并策略有时候是一种优化的结果，但实际上更多时候说明了表上的索引建的很糟糕：
> * 当出现服务器对多个索引做相交的操作时（通常有多个and），意味着需要一个包含所有列的索引，而不是多个独立列的索引
> *  当服务器需要对多个索引进行联合操作的时候（通常有多个or的条件），通常需要耗费大量的CPU和内存资源在算法的缓存上、排序和合并的操作上，特别是其中有一些索引的选择性不高，需要合并大量扫描的结果的时候

## 3.2.4 选择合适的索引顺序(B-Tree索引)
> 在一个多列的索引中，索引列的顺序意味着索引首先按照最左列进行排序，其次是第二列等等，所以，索引可以按照升序或者降序进行扫描，以满足精确符合列顺序的order by 和 group by 等子句的要求

>