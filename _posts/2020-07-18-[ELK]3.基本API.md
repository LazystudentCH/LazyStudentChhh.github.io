---
layout: post
title:  "[ELK]3.基本API"
date:   2020-07-18 12:02
tags: elasticsearch
color: rgb(255,90,90)
cover: '../coverimages/es.jpg'
---
## 基本操作(Basic Options)
`**获取集群或者节点的健康状态**
```
curl -XGET 'localhost:9200/_cat/health?v'&pretty
cluster 集群名字
status 每当我们查询集群健康情况时，接口可能会返回green，yellow或red状态。green意味着一切良好，yellow意味着所有的数据都是可用的，但是一些复制分片可能没有正确分发（集群的所有功能还是正常的）。red意味着因为某些原因导致有些数据不能使用。注意，即使集群状态是red，它仍然可以运行一部分的功能。（例如，它依然可以从一些可用的分片处理搜索请求）但你应该尽快去修复它，因为这样会使搜索结果丢失一些数据。
```

**查询节点数目**
```
curl -XGET 'localhost:9200/_cat/nodes'
```

**列出所有索引**
```
curl -XGET 'localhost:9200/_cat/indices'
```

**创建索引**
```
curl -XPUT /home_index
```

**添加文档**
```
curl -XPUT 'localhost:9200/home_index/home/1' -H 'content-Type:application/json' -d '{"name":"tom"}'

返回结果:
{
    "_index":"home_index",       //索引
    "_type":"home",               //类型
    "_id":"1",                       //id
    "_version":1,      
    "result":"created",          
    "_shards":{                    
        "total":2,
        "successful":1,
        "failed":0
    },
    "_seq_no":0,
    "_primary_term":1
}
```

**查询文档**

```
curl -XGET 'localhost:9200/home_index/home/1?&pretty'
//pretty 为了让返回的数据更加美观
返回结果:
{
  "_index" : "home_index",
  "_type" : "home",
  "_id" : "1",
  "_version" : 1,
  "_seq_no" : 0,
  "_primary_term" : 1,
  "found" : true,
  "_source" : {
    "name" : "tom"
  }
}


还可以选择性的返回数据
例如 
curl -XGET 'localhost:9200/home_index/home/1/_source?pretty'
返回结果:
{
  "name" : "tom"
}

也可以这样, _source?_source={字段名称}:
curl -XGET 'localhost:9200/home_index/home/1/_source?_source=name&pretty'
返回结果:
{
  "name" : "tom"
}
```

**查询索引下所有文档**
```
curl -XGET 'localhost:9200/home_index/home/_search?pretty
//默认返回十条
返回结果:
{
  "took" : 308,
  "timed_out" : false,
  "_shards" : {
    "total" : 5,
    "successful" : 5,
    "skipped" : 0,
    "failed" : 0
  },
  "hits" : {
    "total" : 1,
    "max_score" : 1.0,
    "hits" : [
      {
        "_index" : "home_index",
        "_type" : "home",
        "_id" : "1",
        "_score" : 1.0,
        "_source" : {
          "name" : "tom"
        }
      }
    ]
  }
}

```


**删除文档**
```
curl -XDELETE 'localhost:9200/home_index/home/1?&pretty' 
```

**判断文档是否存在**
```
curl -XHEAD 'localhost:9200/home_index/home/1'
```


**批量查询(_mget)**
```
curl -XGET 'localhost:9200/home_index/home/_mget?pretty' -H 'content-Type:application/json' -d '{"ids":[1,2]}'

添加 ids参数   即使有id不存在,也不影响其他查询
返回结果:
{
  "docs" : [
    {
      "_index" : "home_index",
      "_type" : "home",
      "_id" : "1",
      "_version" : 1,
      "_seq_no" : 2,
      "_primary_term" : 2,
      "found" : true,
      "_source" : {
        "name" : "tom"
      }
    },
    {
      "_index" : "home_index",
      "_type" : "home",
      "_id" : "2",
      "found" : false
    }
  ]
}

```
这里往后的都用kibana操作
---

**批量操作(_bulk)**
在Elasticsearch中，支持批量的插入、修改、删除操作，都是通过_bulk的api完成的。
请求格式如下：（请求格式不同寻常）
```
{ action: { metadata }}\n
{ request body }\n
{ action: { metadata }}\n
{ request body }\n
注意后面需要有换行符
```

![enter description here](https://raw.githubusercontent.com/LazystudentCH/blogImage/master/2020/7/19/[ELK]3.基本API/1595049081384.png)

查看一下home_index中的文档
```
{
  "took" : 7,
  "timed_out" : false,
  "_shards" : {
    "total" : 5,
    "successful" : 5,
    "skipped" : 0,
    "failed" : 0
  },
  "hits" : {
    "total" : 4,
    "max_score" : 1.0,
    "hits" : [
      {
        "_index" : "home_index",
        "_type" : "home",
        "_id" : "2",
        "_score" : 1.0,
        "_source" : {
          "id" : 2001,
          "name" : "name1",
          "age" : 20,
          "sex" : "男"
        }
      },
      {
        "_index" : "home_index",
        "_type" : "home",
        "_id" : "4",
        "_score" : 1.0,
        "_source" : {
          "id" : 2003,
          "name" : "name3",
          "age" : 20,
          "sex" : "男"
        }
      },
      {
        "_index" : "home_index",
        "_type" : "home",
        "_id" : "1",
        "_score" : 1.0,
        "_source" : {
          "name" : "tom"
        }
      },
      {
        "_index" : "home_index",
        "_type" : "home",
        "_id" : "3",
        "_score" : 1.0,
        "_source" : {
          "id" : 2002,
          "name" : "name2",
          "age" : 20,
          "sex" : "男"
        }
      }
    ]
  }
}

```

一次请求多少性能最高？
整个批量请求需要被加载到接受我们请求节点的内存里，所以请求越大，给其它请求可用的内存就越小。有一
个最佳的bulk请求大小。超过这个大小，性能不再提升而且可能降低。
最佳大小，当然并不是一个固定的数字。它完全取决于你的硬件、你文档的大小和复杂度以及索引和搜索的负
载。
幸运的是，这个最佳点(sweetspot)还是容易找到的：试着批量索引标准的文档，随着大小的增长，当性能开始
降低，说明你每个批次的大小太大了。开始的数量可以在1000~5000个文档之间，如果你的文档非常大，可以
使用较小的批次。
通常着眼于你请求批次的物理大小是非常有用的。一千个1kB的文档和一千个1MB的文档大不相同。一个好的
批次最好保持在5-15MB大小间。

**分页**
es分页接受两个参数，from和size

from:跳过多少个结果
size:返回结果的数量
例如 每页1个结果，跳过前2页
```
GET /home_index/home/_search?size=1&from=2
```
> 应该当心分页太深或者一次请求太多的结果。结果在返回前会被排序。但是记住一个搜索请求常常涉及多个分片。每个分片生成自己排好序的结果，它们接着需要集中起来排序以确保整体排序正确。
返回结果:
```
{
  "took" : 2,
  "timed_out" : false,
  "_shards" : {
    "total" : 5,
    "successful" : 5,
    "skipped" : 0,
    "failed" : 0
  },
  "hits" : {
    "total" : 4,
    "max_score" : 1.0,
    "hits" : [
      {
        "_index" : "home_index",
        "_type" : "home",
        "_id" : "1",
        "_score" : 1.0,
        "_source" : {
          "name" : "tom"
        }
      }
    ]
  }
}
```
> 在集群系统中深度分页
为了理解为什么深度分页是有问题的，让我们假设在一个有5个主分片的索引中搜索。当我们请求结果的第一页（结果1到10）时，每个分片产生自己最顶端10个结果然后返回它们给请求节点(requesting node)，它再排序这所有的50个结果以选出顶端的10个结果。
现在假设我们请求第1000页——结果10001到10010。工作方式都相同，不同的是每个分片都必须产生顶端的10010个结果。然后请求节点排序这50050个结果并丢弃50040个！

> 你可以看到在分布式系统中，排序结果的花费随着分页的深入而成倍增长。这也是为什么网络搜索引擎中任何语句不能返回多于1000个结果的原因。

**映射**

前面我们创建的索引以及插入数据，都是由Elasticsearch进行自动判断类型，有些时候我们是需要进行明确字段类型的，否则，自动判断的类型和实际需求是不相符的。

![enter description here](https://raw.githubusercontent.com/LazystudentCH/blogImage/master/2020/7/19/[ELK]3.基本API/1595051993003.png)
![enter description here](https://raw.githubusercontent.com/LazystudentCH/blogImage/master/2020/7/19/[ELK]3.基本API/1595052007027.png)

> * string类型在ElasticSearch 旧版本中使用较多，从ElasticSearch 5.x开始不再支持string，由text和keyword类型替代。
> * text 类型，当一个字段是要被全文搜索的，比如Email内容、产品描述，应该使用text类型。设置text类型以后，字段内容会被分析，在生成倒排索引以前，字符串会被分析器分成一个一个词项。text类型的字段不用于排序，很少用于聚合。
> * keyword类型适用于索引结构化的字段，比如email地址、主机名、状态码和标签。如果字段需要进行过滤(比如查找已发布博客中status属性为published的文章)、排序、聚合。keyword类型的字段只能通过精确值搜索到。

例如:
```
PUT /home_index/
{
    "settings":{
        "index":{    //设置索引
            "number_of_shards":"2",  //分片数量
            "number_of_replicas":"0"
        }
    },
    "mappings":{ //映射
        "person":{ //type名称
            "properties":{ //属性
                "name":{
                    "type":"text"  //text类型作为全文索引类型 ， 可以被分词
                },
                "age":{
                    "type":"integer" 
                },
                "mail":{
                    "type":"keyword"  //keyword只能被精确匹配
                },
                "hobby":{
                    "type":"text"
                }
            }
        }
    }
}
```

**结构化查询**

**term**
term 主要用于精确匹配哪些值，比如数字，日期，布尔值或 not_analyzed 的字符串
例如:
```
POST /home_index/person/_search
{
  "query": {
    "term": {
      "age":20
    }
  }
}
```

**terms**
```
POST /home_index/person/_search
{
  "query": {
    "terms": {
      "age":[20,21]
    }
  }
}
```

**range**
查找字段满足指定范围的数据
```
POST /home_index/person/_search
{
  "query": {
    "range": {
      "age":{    //字段名称
        "gt":20,  //gt 大于 gte 大于等于
        "lt":25
      }
    }
  }
}

```

**exist**
查找存在某个字段的数据

```
POST /home_index/person/_search
{
  "query": {
    "exists": {
      "field":"age"      //value 填字段名
    }
  }
}
```
**match**
match 查询是一个标准查询，不管你需要全文本查询还是精确查询基本上都要用到它。
如果你使用 match 查询一个全文本字段，它会在真正查询之前用分析器先分析 match 查询的字符
```
POST /home_index/person/_search
{
  "query": {
    "match": {
      "hobby": "跑步游泳"
    }
  }
}
```
返回结果:
```
{
  "took" : 11,
  "timed_out" : false,
  "_shards" : {
    "total" : 2,
    "successful" : 2,
    "skipped" : 0,
    "failed" : 0
  },
  "hits" : {
    "total" : 2,
    "max_score" : 4.5427876,
    "hits" : [
      {
        "_index" : "home_index",
        "_type" : "person",
        "_id" : "mdKOYHMBtcjMt8X-t2vQ",
        "_score" : 4.5427876,
        "_source" : {
          "name" : "赵六",
          "age" : 23,
          "mail" : "444@qq.com",
          "hobby" : "跑步、游泳"
        }
      },
      {
        "_index" : "home_index",
        "_type" : "person",
        "_id" : "mNKOYHMBtcjMt8X-t2vQ",
        "_score" : 1.3862944,
        "_source" : {
          "name" : "王五",
          "age" : 22,
          "mail" : "333@qq.com",
          "hobby" : "羽毛球、篮球、游泳、听音乐"
        }
      }
    ]
  }
}

```
如果给match指定了确切的值，也能精确匹配
```
POST /home_index/person/_search
{
  "query": {
    "match": {
      "age": "20"
    }
  }
}

```
返回结果:
```
{
  "took" : 2,
  "timed_out" : false,
  "_shards" : {
    "total" : 2,
    "successful" : 2,
    "skipped" : 0,
    "failed" : 0
  },
  "hits" : {
    "total" : 1,
    "max_score" : 1.0,
    "hits" : [
      {
        "_index" : "home_index",
        "_type" : "person",
        "_id" : "ltKOYHMBtcjMt8X-t2vQ",
        "_score" : 1.0,
        "_source" : {
          "name" : "张三",
          "age" : 20,
          "mail" : "111@qq.com",
          "hobby" : "羽毛球、乒乓球、足球"
        }
      }
    ]
  }
}

```
**bool查询**

bool 查询可以用来合并多个条件查询结果的布尔逻辑，它包含一下操作符：
must：多个查询条件的完全匹配,相当于 and 。
must_not ： 多个查询条件的相反匹配，相当于 not 。
should ： 至少有一个查询条件匹配, 相当于 or 。
这些参数可以分别继承一个查询条件或者一个查询条件的数组：

```
POST /home_index/person/_search
{
  "query": {
    "bool": {
      "must": [     //必须满足所有条件
        {"term":{"age":20}}
      ],
      "must_not": [   //必须不满足所有条件
        {"term": {"name":"张三" }}
      ],
      "should": [    //满足其中一个即可
        {"term": {"hobby": "足球"}},
        {"term": {"hobby": "篮球"}}
      ]
    }
  }
}
```
