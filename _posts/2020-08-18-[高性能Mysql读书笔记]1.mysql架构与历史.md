---
layout: post
title:  "[高性能Mysql读书笔记]1.mysql架构与历史"
date:   2020-08-18 23:34
tags: Mysql
color: rgb(255,215,0)
cover: '../coverimages/mysql.jpg'
---

## 1.1 Mysql逻辑架构

> mysql逻辑架构图如下

![enter description here](https://raw.githubusercontent.com/LazystudentCH/blogImage/master/2020/8/18/[高性能Mysql读书笔记]1.mysql架构与历史/1597761013970.png)

> 第一层是大多数C/S架构的工具或者服务都有类似的结构，用于连接处理，授权认证和安全等功能。

> 第二层则包括了Mysql的绝大部分核心功能，例如查询解析，分析，优化，缓存以及一些内置函数，所有跨存储引擎的功能都在这一层实现。

> 第三层主要是存储引擎，存储引擎负责Mysql数据的存储和提取。每个存储引擎都有它的优势和劣势，服务器通过API和这些存储引擎通信，这些接口屏蔽了不同存储引擎之间的差异，使得对上层的查询过程透明，存储引擎不会去解析sql（InnoDB例外，会解析外键，因为Mysql本身没有外键），不同存储引擎之间也不会相互通信，而只是简单的相应上层的请求

## 1.1.1 连接的管理与安全
> 每个客户端连接到Mysql都会单独拥有一个线程，该连接的查询只会在这个单独的线程中执行，该线程只能在某个CPU核心中运行，服务器会负责缓存线程，所以不需要频繁的创建和销毁线程(mysql5.5之后，引入的线程池)

> 当客户端连接到Mysql的时候，服务器需要对其进行认证，基于用户名，原始主机信息和密码。

## 1.1.2 优化和执行

> Mysql会解析查询，并且创建内部的数据结构（解析树），然后对其进行各种优化，包括重写查询，选择合适的索引，决定表的顺序等等。用户可以通过特殊的关键字来影响这个过程，也可以请求优化器来explain优化的各个过程，并提供一个参考基准。

>优化器并不关心表使用的是什么存储引擎，但是存储引擎对优化查询是有影响的，优化器在优化的时候，会请求引擎返回某个操作具体的信息，以及表的数据信息等。某些存储引擎的某些索引，可能对一些特定的查询有一定的优化

> 对于SELECT语句，在解析查询之前，服务器会先检查并查询缓存，如果能够在缓存中找到对应的查询，服务器就不必要重新执行后面的流程

## 1.2 并发控制
> 解决并发的问题通常的做法就是实现一个由两种类型组成的锁系统来解决此问题，这两种类型的锁通常被成为共享锁和排他锁，也叫做读锁和写锁，读锁是相互共享的，多个用户可以共享这把锁，可以同时读取一个数据，而不对其他用户造成影响，而写锁是排他的，一个写锁会阻塞其他的写锁和读锁。

## 1.2.1 锁粒度
> 表锁是Mysql中最基础的策略，并且是开销最小的策略，尽管存储引擎可以管理自己的锁策略，但是Mysql本身还是会例用各种有效的表锁来实现目的。例如 ALTER TABLE 之类的语句会使用表锁，而忽略存储引擎的锁机制。

>行锁可以最大程度的支持并发处理（同时也带来了最大的锁开销），在InnoDB以及其他一些存储引擎中实现了行锁，行锁只是在存储引擎层面实现的，而Mysql的服务层没有实现，服务层完全不了解存储引擎中的锁实现


## 1.3.1事务级别

> sql标准中定义了四种隔离级别

>Read UnCommit (读未提交) 在该级别下，即使没有提交的事务，对其他事务也是可见的，这也被称作为脏读，在一般实际中很少用

> Read Commit (读已提交) 简而言之，在事务中，只能看见已经提交的修改，这个级别也被叫做不可重复度，因为有可能在一个事务中，两次读到的数据不一致（在两次读之间，有其他事务修改了数据）

>Repeatable Read (可重复读)，该级别保证了在同一个事务中两次读到的数据是一致的，但是会出现幻读的问题，所谓幻读，就是某个事务两次读取某个范围的数据，但是在这两次读取之间，有另外的事务插入了新的数据，就会产生幻行的问题，这个级别是mysql默认的级别。InnoDB和XtraDB存储引擎通过多版本并发控制解决了幻读问题(MVCC)

>Serilizable(串行化)，最高的级别，通过强制事务来串行执行，解决了幻读的问题，但会导致大量的超时和锁争用的问题

## 1.3.2 事务日志

> 事务日志可以帮助提高事务的效率，使用事务日志，存储引擎在修改表的时候只需要修改内存拷贝，再把该修改行为记录到磁盘中的事务日志，而不是每次都将数据持久化到磁盘中。事务日志采用的是追加文件末尾的方式，是顺序IO，而不是随机IO，所以采用事务日志相对来说快得多，我们也把这种方式称作为预写式日志。

## 1.3.3 Mysql中的事务
>Mysql 提供了两种事务引擎， InnoDB和NDB cluster，另外也还有一些引擎支持事务.

**自动提交**
> Mysql默认启用自动提交的模式，也就是说，如果不显示的开启一个事务，每个查询都会被当作一个事务来执行，可以通过设置AUTOCOMMIT来启用或者禁用自动提交