---
layout: post
title:  "[高性能Mysql读书笔记]1.mysql架构与历史"
date:   2020-08-18 23:34
tags: Mysql
color: rgb(255,215,0)
cover: '../coverimages/mysql.jpg'
---

## 1.1 Mysql逻辑架构

> mysql逻辑架构图如下

![enter description here](https://raw.githubusercontent.com/LazystudentCH/blogImage/master/2020/8/18/[高性能Mysql读书笔记]1.mysql架构与历史/1597761013970.png)

> 第一层是大多数C/S架构的工具或者服务都有类似的结构，用于连接处理，授权认证和安全等功能。

> 第二层则包括了Mysql的绝大部分核心功能，例如查询解析，分析，优化，缓存以及一些内置函数，所有跨存储引擎的功能都在这一层实现。

> 第三层主要是存储引擎，存储引擎负责Mysql数据的存储和提取。每个存储引擎都有它的优势和劣势，服务器通过API和这些存储引擎通信，这些接口屏蔽了不同存储引擎之间的差异，使得对上层的查询过程透明，存储引擎不会去解析sql（InnoDB例外，会解析外键，因为Mysql本身没有外键），不同存储引擎之间也不会相互通信，而只是简单的相应上层的请求

## 1.1.1 连接的管理与安全
> 每个客户端连接到Mysql都会单独拥有一个线程，该连接的查询只会在这个单独的线程中执行，该线程只能在某个CPU核心中运行，服务器会负责缓存线程，所以不需要频繁的创建和销毁线程(mysql5.5之后，引入的线程池)

> 当客户端连接到Mysql的时候，服务器需要对其进行认证，基于用户名，原始主机信息和密码。

## 1.1.2 优化和执行

> Mysql会解析查询，并且创建内部的数据结构（解析树），然后对其进行各种优化，包括重写查询，选择合适的索引，决定表的顺序等等。用户可以通过特殊的关键字来影响这个过程，也可以请求优化器来explain优化的各个过程，并提供一个参考基准。

>优化器并不关心表使用的是什么存储引擎，但是存储引擎对优化查询是有影响的，优化器在优化的时候，会请求引擎返回某个操作具体的信息，以及表的数据信息等。某些存储引擎的某些索引，可能对一些特定的查询有一定的优化

> 对于SELECT语句，在解析查询之前，服务器会先检查并查询缓存，如果能够在缓存中找到对应的查询，服务器就不必要重新执行后面的流程

## 1.2 并发控制
> 解决并发的问题通常的做法就是实现一个由两种类型组成的锁系统来解决此问题，这两种类型的锁通常被成为共享锁和排他锁，也叫做读锁和写锁，读锁是相互共享的，多个用户可以共享这把锁，可以同时读取一个数据，而不对其他用户造成影响，而写锁是排他的，一个写锁会阻塞其他的写锁和读锁。

## 1.2.1 锁粒度
> 表锁是Mysql中最基础的策略，并且是开销最小的策略，尽管存储引擎可以管理自己的锁策略，但是Mysql本身还是会例用各种有效的表锁来实现目的。例如 ALTER TABLE 之类的语句会使用表锁，而忽略存储引擎的锁机制。

>行锁可以最大程度的支持并发处理（同时也带来了最大的锁开销），在InnoDB以及其他一些存储引擎中实现了行锁，行锁只是在存储引擎层面实现的，而Mysql的服务层没有实现，服务层完全不了解存储引擎中的锁实现

