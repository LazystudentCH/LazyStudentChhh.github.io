---
layout: post
title:  "[高性能Mysql读书笔记]2.schema与数据类型优化"
date:   2020-08-23 13:07
tags: Mysql
color: rgb(255,215,0)
cover: '../coverimages/mysql.jpg'
---

##  2.1选择优化的数据类型

> mysql中的数据类型非常多，选择正确的数据类型对获得高性能至关重要，不管存储哪种类型的数据，下面几个简单的原则都有利于做出更好的选择
> * 更小的通常更好
	> 一般情况下，应该尽量使用可以正确存储数据的最小类型，更小的数据类型通常更快(例如tiny int)，因为他们占用更少的磁盘，内存和CPU缓存，并且处理的时候，CPU需要的周期也更少，但是需要没有低估存储值的范围
> * 简单就好
	> 简单的数据类型通常需要更少的CPU周期，例如，操作int的代价比string类型更低，因为字符集的排序规则比整型更加复杂。这里有两个例子，一个是应该使用Mysql的内建类型，例如date datetime timestamp来存储时间和日期而不是字符串，另外一个是应该用整形来存储IP地址
> * 尽量避免Null
	> 如果查询中包含Null的列，对Mysql来说更难优化，因为可为Null的列使得索引，索引统计和值比较都更为复杂，可为Null还需要花费更多的存储空间，在Mysql中也需要特殊处理，每个索引需要记录一个额外的字节，但是通常把Null变为不可为Null对性能的提升较小

> 下一步是选择具体的数据类型，很多Mysql的数据类型可以存储相同的类型和数据，只是存储的长度和范围不一样、允许的精度不同，或者需要不同的物理空间。例如： DATETIME和TIMESTAMP列都可以存储相同类型的数据，时间和日期，精确到秒，但是TIMESTAMP只需要DATETIME一半的存储空间，并且拥有自动更新的能力，根据时区自动变化，另一方面，TIMESTAMP允许的时间范围要比DATETIME小得多，有时候它的特殊能力会成为障碍

## 2.2 整数类型
> 如果存储整型，可以用tinyint smallint mediumint int bigint 分别使用8,16,24,32,64来存储，整型大多都用unsiged选项，表示不允许负值，而这可以使得正数的范围翻倍，有符号和无符号使用相同的存储空间，并具有相同的性能

> Mysql可以为整数类型指定宽度，例如INT(11)，这里对大多数应用都是没有意义的，它不会限制数据的合法范围，只是表示可以显示的字符个数，对于存储和计算来说int(1)和int(20)是一样的。

## 2.3 实数类型
> 实数是带有小数部分的数字，float使用4个字节，double使用8个字节，和整数类型一样，只能选择存储类型，Mysql内部使用double作为内部浮点的计算类型

## 2.4 字符串类型
> Mysql支持多种字符串类型，每种类型还有很多变种

## 2.4.1 VARCHAR
> VARCHAR和CHAR是两种最主要的字符串类型。比较难解释这两种值是如何在磁盘和内存中存储的，因为各个存储引擎的实现不同，下文将主要以InnoDB和MyISAM来说明

>VARCHAR类型用于存储可变长字符串，是最常见的数据类型，它比定长类型更加节省空间，因为它仅仅使用必要的空间，但是有一种情况例外，就是ROW_FORMAT=FIXED的话，就会使得每一行都使用定长存储，这会很浪费空间

>VARCHAR需要用一个或者两个字节来存储字符串长度，如果字符串的长度小于等于255，则需要一个字节，否则需要两个字节，VARCHAR（255）一个字节存储长度，因为最大长度为255

>VARCHAR节省了存储空间，所以对性能也有帮助，但是由于行是变长的，在update的时候由于可能使行变得更长，这就导致需要做额外的工作，如果一个行占用的空间增大，并且在页内没有多余的空间来存储，这种情况下，MyISAM和InnoDB处理方式是不一样的，MyISAM会将行拆成不同的片段来存储，则需要分裂页来使得行可以放进页内

> VARCHAR会保留末尾的空格

![enter description here](https://raw.githubusercontent.com/LazystudentCH/blogImage/master/2020/8/24/[高性能Mysql读书笔记]2.schema与数据类型优化/1598280167799.png)

## 2.4.2 CHAR类型
> CHAR类型是定长的，Mysql总是根据定义的字符串长度来分配足够的空间，当存储CHAR的时候,Mysql会删除末尾的所有空格，CHAR非常适合长度相近的字符串，若长度不足，会采用空格来填充。

## 2.4.3 BLOB和TEXT类型
> 与其他类型不同，Mysql会把每个blob和TEXT值当作一个独立的对象来处理，存储引擎在存储的时候通常会做特殊处理，在存储的值过大的时候，InnoDB会专门用一个“外部”的区域来存储，此时需要一个1~4字节来存储指针，然后在外部存储区域存储实际的值

> 所有的Blob类型和TEXT类型不同的地方是，BLOB是存储二进制数据，没有排序规则或者字符集，而TEXT有字符集

> MysqldduiBLOB和TEXT进行排序是和其他类型不同的，它只对钱max_sort_length个字节进行排序

## 2.5 日期和时间类型

> Mysql可以使用许多类型来保存日期和时间的值，Mysql能存储的最小时间粒度为秒(MariaDB为微秒)

## 2.5.1 DATETIME
> 这个类型可以保存大范围的值，从1001年到9999年，精度为秒，它把日期和时间封装到YYYYMMDDHHMMSS的格式中，与时区无关，默认情况下，Mysql以2008-01-16 22:37:08 的格式显示，该字段是可以排序的

## 2.5.2 TIMESTAMP
> TIMESTAMP就像它的名字一样，TIMESTAMP保存了从1970年1月1日开始到现在的时间戳，最多保存到1970年到2038年，在Mysql4.0以及更高的版本中，TIMESTAMP会按照DATETIME的格式来格式化时间，TIMESTAMP收到时区影响（可以设置），TIMESTAMP还有一个特殊属性，如果插入的时候没有指定TIMESTAMP的值，会自动更新为当前时间，可以配置TIMESTAMP列的插入和更新行为

>除了特殊行为之外,应该使用TIMESTAMP，它比DATETIME效率更高

## 2.6 选择合适的标识符

> 为列选择合适的数据类型非常重要，选择类型的时候，不仅仅需要考虑存储类型，还要考虑Mysql对这种类型如何计算执行和比较，一旦选择了一种类型，要确保所有关联的表中都是用相同的类型，包括像unsinged这样的属性。混用不同的数据类型可能导致性能问题，在比较的时候发生隐性的类型转换也很难发现

>在可以满足值的范围需求，并且能预留未来增长空间的前提下，尽量选择最小的数据类型，下面是一些小技巧

>* 整数类型作为标识列通常是最好的选择，因为他们性能很快并且可以自动递增
>* 如果可能，尽量避免使用字符串类型作为标识列，因为它们很消耗空间而且通常比数字类型慢，尤其是在MYISAM中，MyISAM对字符串使用压缩索引，这会导致查询慢得多，最多可能有6倍的性能下降
>* 对于完全随机的字符串也要注意，例如MD5，UUID这些，这些函数生成的值会任意分布在很大的空间内，导致Select和一些Insert语句变的很慢，原因如下:
	>1.因为插入值会随机的写到索引的不同位置，这会使得Insert语句更慢，因为导致页分裂和磁盘随机访问
	>2.Select语句会更慢，因为逻辑上相邻的行会分布在磁盘和内存不同的地方
	>3.随机值导致缓存对所有类型的查询语句效果都很差，因为会使得缓存赖以生存的局部性访问原理失效

## 2.7 总结
> * 避免过度设计，过度设计会导致级其复杂的schama设计
> * 选择小而合适的数据类型，并且尽量避免null
> * 尽量选用相同的类型存储相关的值，特别是在关联条件中使用的列
> * 注意可变长的字符串类型(VARCHAR)，在临时表和排序的时候会悲观的按最大长度来分配内存
> * 尽量使用整数来定义标识列
> * 避免使用Mysql遗弃的特性，例如指定浮点数的精度和显示整数的宽度
> * 小心使用ENUM和SET